#include <iostream>
#include <map>
#include <ctime>
#include <cstring>
#include <string>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/un.h>
#include <ifaddrs.h>
#include <sys/ioctl.h>
#include <net/if.h>

#define DISCOVERY_PORT 50000
#define UNIX_SOCK_PATH "/tmp/neighbor_service.sock"
#define ACTIVE_TIMEOUT 30

// Struct to store neighbor info
struct Neighbor {
    std::string ip;
    std::string mac;
    time_t lastSeen;
};

std::map<std::string, Neighbor> neighbors;

// Helper: get MAC address of an interface
std::string get_mac(const char* ifname) {
    int fd = socket(AF_INET, SOCK_DGRAM, 0);
    if (fd < 0) return "";
    struct ifreq ifr;
    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ-1);
    if (ioctl(fd, SIOCGIFHWADDR, &ifr) == 0) {
        unsigned char *mac = (unsigned char*)ifr.ifr_hwaddr.sa_data;
        char buf[18];
        snprintf(buf, sizeof(buf), "%02x:%02x:%02x:%02x:%02x:%02x",
                 mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
        close(fd);
        return std::string(buf);
    }
    close(fd);
    return "";
}

// Setup UDP discovery socket
int setup_udp_socket() {
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if (sock < 0) return -1;

    int yes = 1;
    setsockopt(sock, SOL_SOCKET, SO_BROADCAST, &yes, sizeof(yes));

    sockaddr_in addr;
    memset(&addr, 0, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_port = htons(DISCOVERY_PORT);
    addr.sin_addr.s_addr = INADDR_ANY;
    if (bind(sock, (sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return -1;
    }
    return sock;
}

// Setup Unix domain socket for CLI communication
int setup_unix_socket() {
    unlink(UNIX_SOCK_PATH);
    int sock = socket(AF_UNIX, SOCK_STREAM, 0);
    if (sock < 0) return -1;

    sockaddr_un addr;
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, UNIX_SOCK_PATH, sizeof(addr.sun_path)-1);

    if (bind(sock, (sockaddr*)&addr, sizeof(addr)) < 0) {
        close(sock);
        return -1;
    }
    if (listen(sock, 5) < 0) {
        close(sock);
        return -1;
    }
    return sock;
}

// Broadcast HELLO messages on all interfaces
void send_hello(int udpSock) {
    struct ifaddrs *ifaddr;
    if (getifaddrs(&ifaddr) == -1) return;

    for (struct ifaddrs *ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        if (!ifa->ifa_addr || ifa->ifa_addr->sa_family != AF_INET) continue;

        char ip[INET_ADDRSTRLEN];
        void *addr_ptr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
        inet_ntop(AF_INET, addr_ptr, ip, sizeof(ip));

        std::string mac = get_mac(ifa->ifa_name);
        if (mac.empty()) continue;

        sockaddr_in baddr;
        memset(&baddr, 0, sizeof(baddr));
        baddr.sin_family = AF_INET;
        baddr.sin_port = htons(DISCOVERY_PORT);
        baddr.sin_addr.s_addr = inet_addr("255.255.255.255");

        std::string msg = std::string("HELLO ") + ip + " " + mac;
        sendto(udpSock, msg.c_str(), msg.size(), 0, (sockaddr*)&baddr, sizeof(baddr));
    }
    freeifaddrs(ifaddr);
}

// Handle incoming UDP HELLO
void handle_udp(int udpSock) {
    char buf[256];
    sockaddr_in sender;
    socklen_t slen = sizeof(sender);
    int len = recvfrom(udpSock, buf, sizeof(buf)-1, 0, (sockaddr*)&sender, &slen);
    if (len > 0) {
        buf[len] = '\0';
        if (strncmp(buf, "HELLO ", 6) == 0) {
            char ip[64], mac[64];
            if (sscanf(buf, "HELLO %63s %63s", ip, mac) == 2) {
                Neighbor n;
                n.ip = ip;
                n.mac = mac;
                n.lastSeen = time(NULL);
                neighbors[ip] = n;
            }
        }
    }
}

// Handle CLI request via Unix socket
void handle_cli(int unixSock) {
    int cliSock = accept(unixSock, NULL, NULL);
    if (cliSock < 0) return;

    std::string reply;
    time_t now = time(NULL);

    for (std::map<std::string, Neighbor>::iterator it = neighbors.begin(); it != neighbors.end();) {
        if (now - it->second.lastSeen > ACTIVE_TIMEOUT) {
            it = neighbors.erase(it); // remove stale
        } else {
            reply += it->second.ip + " " + it->second.mac + "\n";
            ++it;
        }
    }

    if (reply.empty()) reply = "No active neighbors\n";

    write(cliSock, reply.c_str(), reply.size());
    close(cliSock);
}

int main() {
    int udpSock = setup_udp_socket();
    int unixSock = setup_unix_socket();
    if (udpSock < 0 || unixSock < 0) {
        std::cerr << "Failed to set up sockets\n";
        return 1;
    }

    time_t lastHello = 0;

    while (1) {
        fd_set fds;
        FD_ZERO(&fds);
        FD_SET(udpSock, &fds);
        FD_SET(unixSock, &fds);
        int maxfd = (udpSock > unixSock ? udpSock : unixSock) + 1;

        timeval tv;
        tv.tv_sec = 1;
        tv.tv_usec = 0;

        int rv = select(maxfd, &fds, NULL, NULL, &tv);
        if (rv > 0) {
            if (FD_ISSET(udpSock, &fds)) handle_udp(udpSock);
            if (FD_ISSET(unixSock, &fds)) handle_cli(unixSock);
        }

        time_t now = time(NULL);
        if (now - lastHello >= 5) {
            send_hello(udpSock);
            lastHello = now;
        }
    }
}
